#include <iostream>
#include <cmath>

using namespace std;
const int N = 5;

//А - матрица коэффициентов b - вектор правых частей x - результат
void solveSystem(double A[N][N], double b[N], double x[N]) {
    double tempA[N][N]; //копия матрицы A
    double tempB[N];    //копия вектора b

    //копируем исходные данные
    for (int i = 0; i < N; i++) {
        tempB[i] = b[i];
        for (int j = 0; j < N; j++) {
            tempA[i][j] = A[i][j];
        }
    }

    //прямой ход метода Гаусса
    for (int i = 0; i < N; i++) {
        double diag = tempA[i][i]; //делим текущую строку на диагональный элемент
        for (int j = i; j < N; j++) {
            tempA[i][j] /= diag;
        }
        tempB[i] /= diag;

        //вычитаем текущую строку из всех нижележащих строк
        for (int k = i + 1; k < N; k++) {
            double factor = tempA[k][i]; //коэффициент для вычитания
            for (int j = i; j < N; j++) {
                tempA[k][j] -= factor * tempA[i][j];
            }
            tempB[k] -= factor * tempB[i];
        }
    }

    //обратный ход метода Гаусса
    for (int i = N - 1; i >= 0; i--) {
        x[i] = tempB[i]; // начинаем с правой части

        //вычитаем уже найденные переменные
        for (int j = i + 1; j < N; j++) {
            x[i] -= tempA[i][j] * x[j];
        }
    }
}

//функция для вычисления определителя матрицы
double opredelitel(double A[N][N]) {
    double tempA[N][N]; // копия матрицы
    double det = 1.0;

    for (int i = 0; i < N; i++) { //копируем матрицу
        for (int j = 0; j < N; j++) {
            tempA[i][j] = A[i][j];
        }
    }

    //приводим матрицу к треугольному виду
    for (int i = 0; i < N; i++) {
        if (fabs(tempA[i][i]) < 0.000001) { //если диагональный элемент равен 0 то меняем строки
            det = 0.0; //определитель равен 0
            break;
        }

        det *= tempA[i][i]; //умножаем на диагональный элемент

        for (int k = i + 1; k < N; k++) { //обнуляем элементы ниже диагонали
            double factor = tempA[k][i] / tempA[i][i];
            for (int j = i; j < N; j++) {
                tempA[k][j] -= factor * tempA[i][j];
            }
        }
    }

    return det;
}

//функция для вычисления обратной матрицы
void calculateInverse(double A[N][N], double inverse[N][N]) {
    double extended[N][2 * N];

    for (int i = 0; i < N; i++) { //заполняем левую часть матрицей A
        for (int j = 0; j < N; j++) {
            extended[i][j] = A[i][j];
        }
    }

    for (int i = 0; i < N; i++) {  //заполняем правую часть единичной матрицей
        for (int j = 0; j < N; j++) {
            extended[i][N + j] = (i == j) ? 1.0 : 0.0; //единицы на диагонали нули в остальных местах
        }
    }

    //прямой ход
    for (int i = 0; i < N; i++) {
        double diag = extended[i][i]; //делим строку на диагональный элемент
        for (int j = 0; j < 2 * N; j++) {
            extended[i][j] /= diag;
        }

        for (int k = 0; k < N; k++) {
            if (k != i) { //обнуляем элементы ниже диагонали в левой части
                double factor = extended[k][i];
                for (int j = 0; j < 2 * N; j++) {
                    extended[k][j] -= factor * extended[i][j];
                }
            }
        }
    }

    for (int i = 0; i < N; i++) { //копируем эту матрицу как обратную
        for (int j = 0; j < N; j++) {
            inverse[i][j] = extended[i][N + j];
        }
    }
}

void printSolution(double x[N]) {
    cout << "Решение системы:\n";
    for (int i = 0; i < N; i++) {
        cout << "x" << i + 1 << " = ";
        cout.precision(4);
        cout << fixed << x[i] << endl;
    }
    cout << endl;
}

void printMatrix(double M[N][N], string name) {
    cout << name << ":\n";
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            //устанавливаем точность и фиксированный формат
            cout.precision(4);
            cout << fixed << M[i][j] << "\t";
        }
        cout << endl;
    }
    cout << endl;
}

int main() {
    setlocale(LC_ALL, "RU");
    cout.precision(4);
    cout << fixed;

    int choice;

    cout << "1. Решение системы уравнений\n";
    cout << "2. Вычисление определителя\n";
    cout << "3. Нахождение обратной матрицы\n";
    cout << "========================================\n";
    cout << "Введите номер задания (1-3): ";

    cin >> choice;
    cout << endl;

    switch (choice) {
    case 1: {
        cout << "Задание 1 решение системы уравнений\n";

        double A[N][N] = {
            {5.38, 7.33, -0.24, -0.49, -8.41},
            {2.81, -4.69, -6.13, -3.05, -5.19},
            {7.60, 4.78, 8.59, 0.98, 6.72},
            {-8.44, -8.53, 5.76, -8.34, 4.96},
            {0.61, 4.63, -4.04, 1.72, 3.61}
        };

        double b[N] = { 4.27, 5.77, 3.70, 5.95, -6.77 };
        double x[N];

        solveSystem(A, b, x);
        printSolution(x);
        break;
    }

    case 2: {
        cout << "Задание 2: вычисление определителя\n";

        double B[N][N] = {
            {-6.32, 4.51, -3.84, -7.38, -6.56},
            {4.22, -4.13, -4.16, -1.93, 6.36},
            {1.90, -2.56, -3.94, -1.61, -8.84},
            {7.29, -1.49, 1.79, 6.11, 8.00},
            {-0.70, -2.39, -4.08, -6.90, 1.65}
        };

        double det = opredelitel(B);
        cout << "Определитель матрицы: " << det << "\n\n";
        break;
    }

    case 3: {
        cout << "Задание 3 нахождение обратной матрицы\n";

        double C[N][N] = {
            {0.38, 1.83, 5.88, -5.62, 3.33},
            {6.65, -7.51, -5.84, 2.54, -5.38},
            {-1.37, -2.32, 6.00, 8.49, 3.03},
            {-8.46, 4.73, -1.71, 7.04, -2.11},
            {-7.34, -1.04, -6.43, -4.91, -7.14}
        };

        double inverse[N][N];
        calculateInverse(C, inverse);
        printMatrix(inverse, "Обратная матрица");
        break;
    }

    default: {
        cout << "Ошибка! Введите число от 1 до 3\n";
        break;
    }
    }

    return 0;
}
